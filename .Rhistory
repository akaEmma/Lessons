## ------------------------------------------------------------------------
check_exer_1_v0("c(1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4)")
## ------------------------------------------------------------------------
check_exer_1_v1 <- function(USER_CODE) {
code <- for_checkr(USER_CODE)
line_binding(code, rep(1:4, each = 3), passif(TRUE, "Just what I wanted!"),
message = "Sorry. Not exactly what I was looking for.")
}
## ------------------------------------------------------------------------
check_exer_1_v1("c(1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4)")
## ------------------------------------------------------------------------
check_exer_1_v1("x <- rep(1:4,each=3); x")
## ------------------------------------------------------------------------
check_exer_1_v1("x <- 1:4; rep(x, each = 3)")
check_exer_1_v1("sort(rep(1:4, 3))")
## ------------------------------------------------------------------------
check_exer_1_v2 <- function(USER_CODE) {
code <- for_checkr(USER_CODE)
desired <- rep(1:4, each = 3)
line_a <- line_calling(code, rep, message = "I'm not seeing where you used `rep()`.")
t1 <- vector_arg(line_a, insist(all(V == 1:4), "Where did you use `1:4`?"))
if (failed(t1)) return(t1)
line_where(code, insist(all(V == desired), "Your vector is {{V}}. That is not the result asked for."))
}
## ------------------------------------------------------------------------
check_exer_1_v2("x <- 1:4; rep(x, each = 3)")
check_exer_1_v2("sort(rep(1:4, 3))")
## ------------------------------------------------------------------------
check_exer_1_v3 <- function(USER_CODE) {
code <- for_checkr(USER_CODE)
desired <- rep(1:4, each = 3)
LineA <- line_calling(code, rep, message = "I'm not seeing where you used `rep()`.")
t1 <- vector_arg(LineA, insist(all(V == 1:4), "Where did you use `1:4`?"))
if (failed(t1)) return(t1)
rep_call <- arg_calling(LineA, rep) # in case rep() is buried in another function application, e.g. 1 * rep()
t2 <- named_arg(rep_call, "each",
insist(V == 3, "Remember, you want 12 elements in the output made from the 4 elements in the input"),
message = "See what use you can make of the `each` argument to rep().")
if (failed(t2)) return(t2)
line_where(code, insist(all(V == desired), "Your vector is {{V}}. That is not the result asked for."))
}
## ------------------------------------------------------------------------
# this is file check_bee_data.R
s1 <- quote(Circuits <- read.csv("http://www.lock5stat.com/datasets/HoneybeeCircuits.csv"))
s2 <- quote(Circuits <- load("http://www.lock5stat.com/datasets/HoneybeeCircuits.csv"))
s3 <- quote(read.csv("http://www.lock5stat.com/datasets/HoneybeeCircuits.csv"))
s4 <- quote(bees <- read.csv("http://www.lock5stat.com/datasets/HoneybeeCircuits.csv"))
## ------------------------------------------------------------------------
# we are still in the file check_bee_data.R
check_bee_data <- function(USER_CODE) {
code <- for_checkr(USER_CODE)
# The messages
m1 <- "Right!"
m2 <- "Notice that the filename has a CSV extension. `load()` is for reading RDA files. Try `read.csv()` instead."
m3 <- "Remember to store the contents of the data file under the name `Circuits`."
m4 <- "Store the data under the name `Circuits`, not `{{Z}}`."
# The checking statements will follow
}
## ------------------------------------------------------------------------
# also in the file check_bee_data.R
check_bee_data <- function(USER_CODE) {
code <- for_checkr(USER_CODE)
# The messages
m1 <- "Right!"
m2 <- "Notice that the filename has a CSV extension. `{{F}}` is for reading RDA files. Try `read.csv()` instead."
m3 <- "Remember to store the contents of the data file under the name `Circuits`."
m4 <- "Store the data under the name `Circuits`, not `{{Z}}`."
browser()
result <- line_where(code,
passif(Z == "Circuits"),
failif(Z == "", m3),
failif(TRUE, m4))
return(result) # return the result of the checking
}
## ------------------------------------------------------------------------
# just checking ...
check_bee_data(s3)
check_bee_data(s4)
## ----eval = FALSE--------------------------------------------------------
#  # this will go in the `check_bee_data()` function
#  result <- line_where(result, insist(F == "read.csv", m2))
## ----results = "hide"----------------------------------------------------
x <- 3 / 5
sqrt(x)
## ----eval = FALSE--------------------------------------------------------
#  paste("How now",
#        color, animal,
#        "?")
## ------------------------------------------------------------------------
sqrt
## ------------------------------------------------------------------------
y <- quote(foo(f, g))
## ------------------------------------------------------------------------
y        # display printed form
class(y) # the object's class
## ------------------------------------------------------------------------
as.list(y)
## ------------------------------------------------------------------------
lapply(y, class)
## ------------------------------------------------------------------------
y <- quote(x ^ 2)
class(y)
as.list(y)
## ------------------------------------------------------------------------
y <- quote(foo(f + 3, paste("Hello,", g, "Nice to meet you.")))
## ------------------------------------------------------------------------
y
class(y)
as.list(y)
lapply(y, class)
## ------------------------------------------------------------------------
y[[3]]
class(y[[3]])
as.list(y[[3]])
lapply(y[[3]], class)
## ----error = TRUE--------------------------------------------------------
eval(y)
## ------------------------------------------------------------------------
subset(mtcars, hp > 250)
## ------------------------------------------------------------------------
y <- quote(subset(mtcars, hp > 250))
as.list(y)
lapply(y, class)
## ----error = TRUE--------------------------------------------------------
eval(quote(hp > 250))
## ------------------------------------------------------------------------
y <- quote({who <- "Alfred"; paste("Welcome,", who)})
y
## ------------------------------------------------------------------------
y <- quote(x <- foo(f,g))
class(y)
as.list(y)
## ------------------------------------------------------------------------
s1 <- quote(Bees <- read.csv("bee_file.csv"))
code <- for_checkr(s1)
## ----eval = FALSE--------------------------------------------------------
#  USER_CODE <- quote({x <- sqrt(cos(pi)); Health <- data.frame(blood_pressure = c(120, 130, 115))})
#  code <- for_checkr(USER_CODE)
#  L1 <- line_where(code,
#                   insist(is.data.frame(V), "Didn't find an appropriate statement producing a dataframe."),
#                   insist("blood_pressure" %in% names(V),
#                          "The dataframe didn't include the variable `blood_pressure`"))
#  L1
## ------------------------------------------------------------------------
L2 <- line_calling(code, sin, cos, tan, message = "No trig function called.")
L2
## ------------------------------------------------------------------------
USER_CODE <- quote(mod <- lm(mpg ~ hp + cyl, data = mtcars))
code <- for_checkr(USER_CODE)
L1 <- line_calling(code, lm)
named_arg(L1, "data", insist(nrow(V) == 100,
"Please use exactly 100 cases for fitting. You used {{nrow(V)}} cases."))
## ----echo = FALSE--------------------------------------------------------
library(ggplot2)
ggplot(mtcars, aes(x = mpg, y = hp, color = cyl)) +
geom_point()
## ----eval = FALSE--------------------------------------------------------
#  library(ggplot2)
#  ggplot(mtcars, aes(x = ____, y = ____, color = ____)) +
#    ____()
## ----echo = FALSE--------------------------------------------------------
submission <- "library(ggplot2);
ggplot(mtcars, aes(x = hp, y = mpg, color = cyl)) +
geom_point()"
## ----echo = FALSE--------------------------------------------------------
print_function_contents(
check_exer_14,
from_file = system.file("learnr_examples/internal-examples.R",
package = "checkr"),
just_the_body = FALSE)
## ------------------------------------------------------------------------
check_exer_14(submission)
## ------------------------------------------------------------------------
CODE <- for_checkr(quote(15 * cos(53)))
t1 <- line_calling(CODE, sin, cos, tan, message = "You should be using a trigonometric function.")
miss1 <- line_calling(t1, cos)
t1 <- misconception(t1, miss1, message = "Are you sure cosine is the right choice?")
t1 <- line_where(t1,
insist(F == "*",
"Remember to multiply by the length of the hypotenuse"))
line_where(t1, insist(is.numeric(V)),
insist(abs(V - 11.98) < 0.01,
"{{V}} is a wrong numerical result. It should be about 11.98."))
## ------------------------------------------------------------------------
chk_exer_9 <- function(USER_CODE) {
code <- for_checkr(USER_CODE)
t1 <- line_chaining(code, message = "Remember, chains involve `%>%`.")
check(t1,
insist(identical(V, mtcars %>% group_by(cyl) %>% summarise(disp = mean(disp))),
"Your chain doesn't produce the right value."),
passif(TRUE, "Great!"))
}
## ------------------------------------------------------------------------
chk_exer_9("mtcars %>% group_by(cyl) %>% summarise(disp = mean(disp))")
chk_exer_9("mtcars %>% group_by(hp) %>% summarise(disp = mean(disp))")
chk_exer_9("res <- group_by(mtcars, cyl); summarise(res, disp = mean(disp))")
## ----eval = FALSE--------------------------------------------------------
#  if_matches(quote(x <- 3 + 2), `<-`(.(nm), ..(val)),
#             passif(nm == quote(X) || nm == quote(x), "{{nm}} was assigned the value {{val}}"))
## ----eval = FALSE--------------------------------------------------------
#  submission <- quote({x <- pi; cos(x)})
#  pattern <- quote(.(fn)(.(var))) # will have to unquote
#  if_matches(submission, !!pattern, passif(TRUE, "Found match"))
#  if_matches(submission, .(fn)(.(var)),
#             passif(fn == quote(cos) && var == quote(x), "Right. The function is {{fn}} on variable {{var}}."))
source("www/check_test.R")
source("/Users/braunsb/Documents/GitHub/a-MESS Lessons/swirl-lapply-and-sapply/www/check_test.R")
head(flags)
question("Why is that not the answer we were looking for?",
answer("Because it applies to the first column only."),
answer("Because it applies to the entire data set rather than to each column.",
correct = TRUE),
answer("I have no idea",
message = "Start with the first R Programming lesson, Basic Building Blocks."),
answer("What's a data frame, and is it also a column?",
message = "A data frame is a two-dimensional data structure in R. It has columns in it that we often call 'variables'."),
random_answer_order = TRUE,
allow_retry = TRUE
)
library(learnr)
question("Why is that not the answer we were looking for?",
answer("Because it applies to the first column only."),
answer("Because it applies to the entire data set rather than to each column.",
correct = TRUE),
answer("I have no idea",
message = "Start with the first R Programming lesson, Basic Building Blocks."),
answer("What's a data frame, and is it also a column?",
message = "A data frame is a two-dimensional data structure in R. It has columns in it that we often call 'variables'."),
random_answer_order = TRUE,
allow_retry = TRUE
)
question("Why is that not the answer we were looking for?",
answer("Because it applies to the first column only.", message = "Whyever would R do something like that?"),
answer("Because it applies to the entire data set rather than to each column.",
correct = TRUE),
answer("I have no idea",
message = "Start with the first R Programming lesson, Basic Building Blocks."),
answer("What's a data frame, and is it also a column?",
message = "A data frame is a two-dimensional data structure in R. It has columns in it that we often call 'variables'."),
random_answer_order = TRUE,
allow_retry = TRUE
)
question("TRUE or FALSE: You don't have to write a loop if you can use `lapply` instead.",
answer("TRUE", correct = TRUE),
answer("FALSE"),
random_answer_order = TRUE,
allow_retry = TRUE
)
cls_list <- lapply(flags, class)
#' You shouldn't see anything happen because the result is being stored in `cls_list` rather than
#' printed to the screen. If you want it to do both, place parentheses around the entire statement
#' as I did in the Solution.
class(cls_list)
sim(class(cls_list))
dim(cls_list)
length(cls_list)
View(flags)
flags
flags <- load("/Users/braunsb/Documents/GitHub/a-MESS Lessons/swirl-lapply-and-sapply/flags.Rdata")
names(flags)
flags <- read.csv("/Users/braunsb/Documents/GitHub/a-MESS Lessons/swirl-lapply-and-sapply/flags.csv")
names(flags)
question("What does `lapply` ALWAYS return?",
answer("a list", correct = TRUE),
answer("a list of lists"),
answer("the same structure you passed to it"),
answer("a list of characters"),
random_answer_order = TRUE,
allow_retry = TRUE
)
question("What does `lapply` ALWAYS return?",
answer("a list", correct = TRUE),
answer("a list of lists", message = "That's a little complicated, don't you think?"),
answer("the same structure you passed to it", message = "Plausible, but false."),
answer("a list of characters", message = "For more help, go back and review the bit about `sapply`."),
random_answer_order = TRUE,
allow_retry = TRUE
)
sapply(flag_colors, sum)
lapply(flag_colors, sum)
head(flag_colors)
rm(list = ls())
# Chunk 1: setup
library(learnr)
tutorial_options(exercise.startover = TRUE,
exercise.eval = TRUE,
exercise.cap = "R Code",
exercise.completion = TRUE,
exercise.diagnostics = TRUE)
library(data.table)
library(dplyr)
flags <- read.csv("/Users/braunsb/Documents/GitHub/a-MESS Lessons/swirl-lapply-and-sapply/flags.csv")
flag_colors <- flags[, 11:17]
flag_shapes <- flags[, 19:23]
shape_mat <- sapply(flag_shapes, range)
unique_vals <- lapply(flags, unique)
knitr::opts_chunk$set(echo = FALSE)
N <- nrow(flags)
cls_list <- lapply(flags, class)
cls_vect <- sapply(cls_list, class)
# Chunk 2: a
# Chunk 3: a-hint-1
head()
# Chunk 4: a-hint-2
head() #put the name of the dataset between the parentheses
# Chunk 5: a-solution
head(flags) #put the name of the dataset between the parentheses
# Chunk 6: b
# Chunk 7: b-solution
dim(flags)
# Chunk 8: d
# Chunk 9: d-solution
class(flags)
# Chunk 10: aa
question("Why is that not the answer we were looking for?",
answer("Because it applies to the first column only.", message = "Whyever would R do something like that?"),
answer("Because it applies to the entire data set rather than to each column.",
correct = TRUE),
answer("I have no idea",
message = "Start with the first R Programming lesson, Basic Building Blocks."),
answer("What's a data frame, and is it also a column?",
message = "A data frame is a two-dimensional data structure in R. It has columns in it that we often call 'variables'."),
random_answer_order = TRUE,
allow_retry = TRUE
)
# Chunk 11: ab
question("TRUE or FALSE: You don't have to write a loop if you can use `lapply` instead.",
answer("TRUE", correct = TRUE),
answer("FALSE"),
random_answer_order = TRUE,
allow_retry = TRUE
)
# Chunk 12: e
# Chunk 13: e-solution
(cls_list <- lapply(flags, class))
# Chunk 14: e-hint
#' You shouldn't see anything happen because the result
#' is being stored in `cls_list` rather than
#' printed to the screen. If you want it to do both,
#' place parentheses around the entire statement
#' as I did in the next (and final) hint.
# Chunk 15: f
# Chunk 16: f-solution
class(cls_list)
length(cls_list)
# Chunk 17: f-hint
class(cls_list)
# Chunk 18: g
# Chunk 19: g-solution
as.character(cls_list)
# Chunk 20: h
# Chunk 21: h-solution
cls_vect <- sapply(flags, class)
# Chunk 22: i
# Chunk 23: i-solution
class(cls_vect)
# Chunk 24: j
# Chunk 25: j-solution
sum(flags$orange)
# Chunk 26: k
# Chunk 27: k-solution
flag_colors <- flags[, 11:17]
# Chunk 28: l
head(flag_colors)
lapply(flag_colors, sum)
rm(list = ls())
question("What do you think `x[is.na(x)]` will give you?",
answer("A vector with no `NA`s", message = "You might get that if you added a '!' somewhere. Try again."),
answer("A vector of `TRUE`s and `FALSE`s", message = "Remember that using logical results within square brackets identifies the actual elements in a vector that correspond to the `TRUE`s, not the logical results of the statement within the brackets."),
answer("A vector of length 0", message  = "That would be correct if there were no `NA`s in the vector."),
answer("A vector of all `NA`s", correct = TRUE, message = "You are amazing!"),
random_answer_order = TRUE,
allow_retry = TRUE
)
question("What do you think `y[y > 0]` will give you?",
answer("A vector of all the positive elements of `y`", correct = TRUE, message = "Well done."),
answer("A vector of all the negative elements of `y`", message = "That would be `y < 0`."),
answer("A vector of all `NA`s", message = "That was the answer to the last question."),
answer("A vector of length 0", message = "That would be right only if there were no elements in `y` greater than 0."),
answer("A vector of `TRUE`s and `FALSE`s", message = "Remember that using logical results within square brackets identifies the actual elements in a vector that correspond to the `TRUE`s, not the logical results of the statement within the brackets."),
random_answer_order = TRUE,
allow_retry = TRUE
)
# Chunk 1: setup
library(learnr)
tutorial_options(exercise.completion = TRUE)
knitr::opts_chunk$set(echo = FALSE)
set.seed(11)
x <- sample(c(rnorm(20),rep(NA,20)),replace = FALSE)
y <- x[!is.na(x)]
# Chunk 2: a
# Chunk 3: a-solution
x
# Chunk 4: b
# Chunk 5: b-solution
x[1:10]
# Chunk 6: c
question("What do you think `x[is.na(x)]` will give you?",
answer("A vector with no `NA`s", message = "You might get that if you added a '!' somewhere. Try again."),
answer("A vector of `TRUE`s and `FALSE`s", message = "Remember that using logical results within square brackets identifies the actual elements in a vector that correspond to the `TRUE`s, not the logical results of the statement within the brackets."),
answer("A vector of length 0", message  = "That would be correct if there were no `NA`s in the vector."),
answer("A vector of all `NA`s", correct = TRUE, message = "You are amazing!"),
random_answer_order = TRUE,
allow_retry = TRUE
)
# Chunk 7: d
# Chunk 8: d-solution
x[is.na(x)]
# Chunk 9: e
# Chunk 10: e-solution
y <- x[!is.na(x)]
# Chunk 11: f
# Chunk 12: f-solution
y
# Chunk 13: g
question("What do you think `y[y > 0]` will give you?",
answer("A vector of all the positive elements of `y`", correct = TRUE, message = "Well done."),
answer("A vector of all the negative elements of `y`", message = "That would be `y < 0`."),
answer("A vector of all `NA`s", message = "That was the answer to the last question."),
answer("A vector of length 0", message = "That would be right only if there were no elements in `y` greater than 0."),
answer("A vector of `TRUE`s and `FALSE`s", message = "Remember that using logical results within square brackets identifies the actual elements in a vector that correspond to the `TRUE`s, not the logical results of the statement within the brackets."),
random_answer_order = TRUE,
allow_retry = TRUE
)
# Chunk 14: h
# Chunk 15: h-solution
y[y > 0]
# Chunk 16: i
# Chunk 17: i-solution
x[x > 0]
# Chunk 18: j
# Chunk 19: j-solution
x[!is.na(x) & x > 0]
# Chunk 20: k
# Chunk 21: k-solution
x[c(3, 5, 7)]
# Chunk 22: l
# Chunk 23: l-solution
x[0]
# Chunk 24: m
# Chunk 25: m-solution
x[3000]
# Chunk 26: n
# Chunk 27: n-solution
x[c(-2, -10)]
# Chunk 28: o
# Chunk 29: o-solution
x[-c(2, 10)]
# Chunk 30: p
# Chunk 31: p-solution
vect <- c(foo = 11, bar = 2, norf = NA)
# Chunk 32: q
# Chunk 33: q-solution
vect
# Chunk 34: r
# Chunk 35: r-solution
names(vect)
# Chunk 36: s
# Chunk 37: s-solution
vect2 <- c(11, 2, NA)
# Chunk 38: t
# Chunk 39: t-solution
names(vect2) <- c("foo", "bar", "norf")
# Chunk 40: u
# Chunk 41: u-solution
identical(vect, vect2)
vect['bar']
vect
vect["bar"]
vect[bar]
question("Which of the following commands do you think would give us the second element of `vect`?",
answer('vect["bar"]'),
answer("vect[bar]",
message = "You'll get `Error: object 'bar' not found` if you try that."),
answer("vect[“2”]"),
answer("vect[“bar”]", message = "R doesn't get along nicely with auto-formatted quotation marks."),
random_answer_order = TRUE,
allow_retry = TRUE
)
vect["bar"]
question("Which of the following commands do you think would give us the second element of `vect`?",
answer('vect["bar"]', correct = TRUE,
message = "Good job!"),
answer("vect[bar]",
message = "You'll get `Error: object 'bar' not found` if you try that."),
answer("vect[“2”]",
message = "R doesn't get along nicely with auto-formatted quotation marks."),
answer("vect[“bar”]",
message = "R doesn't get along nicely with auto-formatted quotation marks."),
random_answer_order = TRUE,
allow_retry = TRUE
)
question("Which of the following commands do you think would give us the second element of `vect`?",
answer('vect["bar"]', correct = TRUE,
message = "Good job!"),
answer("vect[bar]",
message = "You'll get `Error: object 'bar' not found` if you try that."),
answer("vect[“2”]",
message = "R doesn't get along nicely with auto-formatted quotation marks."),
answer("vect[“bar”]",
message = "R doesn't get along nicely with auto-formatted quotation marks."),
random_answer_order = TRUE,
allow_retry = TRUE
)
library(learnr)
tutorial_options(exercise.completion = TRUE)
knitr::opts_chunk$set(echo = FALSE)
set.seed(11)
x <- sample(c(rnorm(20),rep(NA,20)),replace = FALSE)
y <- x[!is.na(x)]
vect <- c(foo = 11, bar = 2, norf = NA)
vect2 <- c(11, 2, NA)
