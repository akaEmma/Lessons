---
title: "Introduction to Python 2: Lists and Strings"
output: 
 learnr::tutorial:
    progressive: true
    allow_skip: true
    css:
      - www/bootstrap.min.css
      - www/flexdashboard.min.css
      - www/style.css
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
options(digits = 3, scipen = 9999)
tutorial_options(exercise.startover = TRUE,
  exercise.eval = TRUE, 
  exercise.cap = "R Code",
  exercise.completion = TRUE,
  exercise.diagnostics = TRUE)
```

## Getting started

In this lesson, we will go deep into two types of Python variables: **lists** and **strings**. 

Lists and strings belong to a family of data types called **sequences**. Sequences store data with a particular order, as opposed to collections that store a bundle of data but do not care particularly what order that data may have. The ordered nature of sequences enables some very important functionality when transforming data. We'll explore common use-cases for lists and strings in this lesson.

Run the code block below (click the Run button in the top-right) to get a quick preview of what we'll cover:

```{python python-fib, exercise=TRUE, exercise.eval=FALSE}
fibonacci_list = [0, 1, 1, 2, 3, 5, 8, 13, 21]
fibonacci_string = "Long before Fibonacci was born, the Fibonacci numbers had a long, rich history in Sanskrit prosody"

print(fibonacci_list)
print(fibonacci_string)
```

You're already creating lists and strings in Pyhton! Now let's get started on learning how to use these variable types.

## Lists

In Python, a **list** is an ordered collection of objects. Python understands lists in a similar way that we think of a to-do list or a grocery list: items in order from first to last.

Let's take the example of a grocery list with five items:

* Cereal
* Vegan pizza
* Waffle fries
* Olive oil
* Coffee

In Python, we use square brackets to indicate we're creating a list, then include each item in the list followed by a comma. In this example, each object in our list is a a **string variable** -- more on this latter. For now, think of a **string** as text surrounded by quotation marks.

Let's create our list in Python, and `print()` the result to screen:

```{python grocery-list, exercise=TRUE, exercise.eval=FALSE}
grocery_list = ["cereal", "vegan pizza", "waffle fries", "olive oil", "coffee"]

print(grocery_list)
```

### List type

In the variable lesson, we described Python as a **dynamically typed** langauge. Do you recall what that means?

```{r dynamic-type, echo=FALSE}
question("What does 'dynamically typed' mean?",
         answer("Python can figure out what data type to use for a new variable based on the value you assign it", correct = TRUE),
         answer("Python runs very quickly on quantum computers"),
         answer("Python is a type of programming language"),
         correct = "Correct!",
         incorrect = "Please try again.",
         random_answer_order = TRUE,
         allow_retry = TRUE
)
```

Because we used square brackets to organize our data when we assigned the new variable, Python inferred that `grocery_list` should be a list. We can check to confirm:

```{python grocery-list-confirm, exercise=TRUE, exercise.eval=FALSE}
grocery_list = ["cereal", "vegan pizza", "waffle fries", "olive oil", "coffee"]

type(grocery_list)
```

### Accessing objects in a list by index 

Every item in a list receives an **index** based on its location in the list. Every index is a whole number, or integer. Think of an index as a number that represents the place in line of our objects -- there's no place 3.1.

We may want to access a specific object in our list by referencing its index, or its place in line. We can do so by calling our list variable, and next to the variable name using square brackets along with an index, such as `my_list_of_items[3]` to access the object at index 3 in `my_list_of_items`.


If we asked Python to return the object at index 1 in `grocery_list`, what object do you think it would return? Let's look:

```{python grocery-list-index, exercise=TRUE, exercise.eval=FALSE}
grocery_list = ["cereal", "vegan pizza", "waffle fries", "olive oil", "coffee"]

print(grocery_list[1])
```

Was this what you expected?

In Python, counting starts at 0 instead of 1. In a list, the "first" item, `"cereal"` is stored at index 0. This can be confusing if you aren't used to counting from 0 in programming languages! To clear up the ambiguity, people sometimes specify "the zero-th element" instead of "the first element" when referencing the item at the beginning of a list. (Python upholds this expectation of counting starting at 0 in most situations, so keep it in mind!)

Take a look at `grocery_list` again. How would you go about accessing `"coffee"` from our list? You actually have two options:
1) Use the index number counting from the beginning, or
2) Count backwards from the end of the list. You can use negative numbers to count from the end of the list. For example, `-1` will return the last item in the list, `-2` to access the second-to-last item, and so on.

Try accessing `"coffee"` both ways below:

```{python grocery-list-last-item, exercise=TRUE, exercise.eval=FALSE}
grocery_list = ["cereal", "vegan pizza", "waffle fries", "olive oil", "coffee"]

# print out "coffee" from the list
```

### List length with the len() function

When we're working with a list like our grocery list, we may want to know just the number of items in the list, or the lenght of the list. For instance, let's get the length of our grocery list items:

```{python grocery-list-len, exercise=TRUE, exercise.eval=FALSE}
grocery_list = ["cereal", "vegan pizza", "waffle fries", "olive oil", "coffee"]

len(grocery_list)
```


### Accessing a list slice

Sometimes you will want to access a subset of your list, or a **slice**. You request a slice using that same `[]` square bracket notation, but this time, you can pass in a range of numbers separated by a colon, like so:

```{python grocery-list-slice, exercise=TRUE, exercise.eval=FALSE}
grocery_list = ["cereal", "vegan pizza", "waffle fries", "olive oil", "coffee"]

print(grocery_list[0:2])
```

Note that Python treats the first number of a slice as **inclusive** and the second number of a slice as **exclusive**. For example, the range `0:2` includes 0 and 1, but omits 2.

Python also allows you to omit the number 0 or the last index, and simply use one index and a colon. For instance, for the example above, we can omit the zero and achieve the same result:

```{python grocery-list-slice-omit, exercise=TRUE, exercise.eval=FALSE}
grocery_list = ["cereal", "vegan pizza", "waffle fries", "olive oil", "coffee"]

print(grocery_list[:2])
```

### Challenge

Who are your five favorite musicians of all time? Create a list `favorite_musicians` below. Then, print only the top 3.


```{python grocery-list-challenge, exercise=TRUE, exercise.eval=FALSE}
# favorite_musicians ... YOUR CODE HERE

# print ... YOUR CODE HERE
```


## List methods

When you create a variable and assign it a list, we automatically create a list **object**. 

In Python, objects are bundles of data and functions that can work together. Python uses a specific object type for each variable type, like integer objects, float objects, list objects, string objects, and so on.

List objects include two main structures. First, they have a container for data - this is its most important feature. Second, a list object also includes a number of helpful functions called **methods**. We can access an object's method by using dot notation, which looks like this: `object_of_some_kind.method()`

If we think of our list object as a car, our data are like the passengers in the interior of the car. Our methods are like the engine, tires, windshield, and brakes: they serve a number of purposes in support of moving the passengers through the world.

Below, we will introduce some useful list methods.

### The .sort() method

Let's create a new list, called long_jump_distances, and provide it several values in no particular order. Then, let's sort the values. To sort a list, we can call the **.sort() method** on our list - the default order is lowest to highest. 

We should use **print() statements** to check the status of our `long_jump_distances` variable before and after the `sort()` method. It's always a good idea to add print() statements to our code to ensure what we *think* is happening is *acutally* happening!

```{python long_jump_distances, exercise=TRUE, exercise.eval=FALSE}
# a list of long jump distances (in meters) in no particular order
long_jump_distances = [3.4, 3.14, 2.99, 1.7, 3.9, 4.1, 4.001, 3.55]
print(long_jump_distances)

# the .sort() method rearranges our values in ascending order
long_jump_distances.sort()

# now print the sorted long_jump_distances list
print(long_jump_distances)
```

### The .append() method

In Python, lists are changeable or **mutable**. This is very important! Some data types can never change, or are **immutable** and must be overwritten instead of modified. With a list, however, we can use methods to modify our data in some way. 

We've already seen one example of list mutation through the `.sort()` method. Our list data transformed into a new sequence of values in descending order.

We may want to add new values to the end of the list. Consider our grocery list from earlier. How would we append a new item to the end of our list? Let's say we wish to append "bananas". Here's what the `.append()` method looks like in action:

```{python grocery-list-to-append, exercise=TRUE, exercise.eval=FALSE}
grocery_list = ["cereal", "vegan pizza", "waffle fries", "olive oil", "coffee"]

item_to_add = "bananas"

grocery_list.append(item_to_add)

print(grocery_list)
```

Note that, as we desired, we added `bananas"` to the end of `grocery_list`. We did **not** add the phrase `"item_to_add"` to the end of this list. Why is that, do you think?

```{r list-var-name, echo=FALSE}
question("Why did we not append the phrase item_to_add in this case?",
         answer("item_to_add is the name of a variable. Python looks for whatever object we assigned to the variable, and that's what gets passed along.", correct = TRUE),
         answer("We put a quotation mark in the wrong place."),
         answer("Python is a weird programming language."),
         correct = "Correct!",
         incorrect = "Please try again.",
         random_answer_order = TRUE,
         allow_retry = TRUE
)
```

When we simply include a name in our Python code without any special punctuation like quotation marks, Python assumes we are referring to a variable name. Then, when we call that `.append()` method, Python will pass along the value associated with that variable. 

(Pro tip: there are some cases where we may wish to pass along the value of our variable, but instead pass along the location of the variable itself. Then, in the future, if we make changes to that variable, it can actually change other variables by accident. That isn't going to happen with this particular example, but keep an eye out for it in the future -- it's caused countless numbers of programmer headaches!!!)

## Strings

In Python, a string is a single sequence of charaacters such as letters, numbers, punctuation, and symbols. You can think of string as "one line of text", although a more accurate definition would be "one single sequence of characters," for reasons we'll explore below.

By default, Python uses the Unicode international character set to define the realm of all possible characters - which spans everything from Latin alphabet letters to hiragana syllables (Japnaese) to mathmatical notation.

### Safely assigning a string

We can use single, double, or even triple quotation marks to define a string - as long as you use the same marks at the beginning and the end of the string. Run the code below to see this in action:

```{python string-defs, exercise=TRUE, exercise.eval=FALSE}
string_one = 'I am a valid string!'

string_two = "I  am also valid!"

string_three = '''Yes I admit I'm the black sheep of the family, but I TOO am valid!'''

type(string_one)
type(string_two)
type(string_three)
```

Choose your opening and closing marks carefully! In particular, watch out for characters within a string that might prematurely end a string, such as an apostraphe. Try to run the code below:

```{python string-break, exercise=TRUE, exercise.eval=FALSE}
string_sheep = 'I'm the black sheep! Bahh!'

print(string_sheep)
```

Your code likely produced an error. What happened here? Try replacing the single quotation marks with a safer punctuation strategy and re-running the code chunk.

### Pro tip: Strings are essentially just lists!

When I described a string as a **sequence** above, you may have thought "wait, that's just like a list!" Indeed, in the family tree of all variable types in Python, strings and lists are close siblings within the Sequence family unit. Sequences have the following properties:

* A set of items
* In a specific order

Unlike lists, strings specialize in dealing with characters, and include specicial methods designed specifically to work with character data. But they also inhereit many of the same general sequence functionality that lists use, too.

For instance, if you'd like to find the length of a string (the number of characters) and the very first (or 0th) element in our list, run the `len()` function below:

```{python string-list-stuff, exercise=TRUE, exercise.eval=FALSE}
string_sheep = "I'm the black sheep! Bahh!"
zeroth = string_sheep[0]

print(length)
print(zeroth)
```

You can also use slice syntax, e.g.:

```{python string-list-sheep-sound, exercise=TRUE, exercise.eval=FALSE}
string_sheep = "I'm the black sheep! Bahh!"
sheep_sound = string_sheep[-5:]

print(sheep_sound)
```

## String methods

String methods are where some of the poewrful text functionality in Python really starts to shine. This is actually a pretty extensive topic, so for now let's introduce some of the most frequently-used methods for manipulating string data.

### Case conversion and mutability with the .lower() method

Want to get rid of case-sensitivity in your data? The easiest way to do this is to coerce all strings to lower case, no matter the content:

```{python string-lower, exercise=TRUE, exercise.eval=FALSE}
python_overview = "Python is a programming language that uses an Object-Oriented paradigm. It was initially developed by Guido Van Rossum."

# run the .lower() method
python_overview.lower()

# print out the variable at the end, just to make sure it worked out
print(python_overview)

```

So wait! In this code, `python_overview.lower()` outputted a lower case string as expected. But why did the final print statements seem to show the original strings without lower case conversion?

This is exactly the kind of issue that happens when some variables are mutable (like lists) and can change, but others (like strings) cannot change. If we wish to "change" the value of a string, such as making it lowercase, we actually have to create a new string variable and overwrite our original variable to point to this new value.

In this case, the line `python_overview.lower()` did not modify the `python_overview` string itself, but rather produced a temporary output of what that would look like. To modify the python_overview variable itself, we must take this output and use the  assignment operator `=` to reassign our variable name to this new string, like so:

```{python string-lower-equals, exercise=TRUE, exercise.eval=FALSE}
python_overview = "Python is a programming language that uses an Object-Oriented paradigm. It was initially developed by Guido Van Rossum."

# run the .lower() method. this time, use the output of this method to reassign the python_overview variable to the new string
python_overview =  python_overview.lower()

# print out the variable at the end, just to make sure it worked out
print(python_overview)

```

Works better this time! We can use `.upper()` in a similar situation, but to coerce a string to upper-case. Rewrite the code chunk above to convert to all capital letters this time (and my apologies in advance for making this tutorial look like it's YELLING AT YOU!)

### The .strip() method

Need to get rid of leading and trailing whitespace in your string? `.strip()` has you covered! Run the example to try it out quickly:

```{python string-strip, exercise=TRUE, exercise.eval=FALSE}
clinical_note = '       Patient displaying Shortness of Breath. 30YO. Consider further Labs. 2020-06-04  '
clinical_note.strip()
print(clinical_note)
```

Oh no! Same problem as last time. Fix the code chunk above so that you reassign `clinical_note` correctly.

Note that you can also chain together multiple methods, as such: `your_object.method1().method2()`. These transformations happen left to right, beginning with method1() (this is similar to the concept of "piping" if you're coming from R/the tidyverse!)

Modify the code chunk above to **also** make the clinical note lower-case only.

### The .split() method

Split into list.

### CHALLENGE

## Review

We've covered a lot of territory! Here are three final questions to answer here.